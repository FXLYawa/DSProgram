# 校园导航项目

## 项目功能

1.顶点相关操作
2.边相关操作
3.从文件中重新加载点与边
4.获取欧拉回路
5.求任意两点间的最短距离
6.求最小生成树
7.求解拓扑受限时的最短路径
8.寻找校内交通瓶颈

## 文件路径说明

源代码文件默认导入路径为相对路径，若出错，请手动改成绝对路径  

## 代码整体说明  

代码共分为四个部分:  

1.图上点和边的操作，函数定义在Graph.cpp文件中

2.并查集操作，函数定义在DSU.cpp文件中

3.图论相关涉及算法的部分，函数定义在Algorithm.cpp文件中

4.主函数部分，即main.cpp

## 数据存储结构说明  

图相关数据存在Graph类中  
NameToID完成了地点名字string与特定数字的映射以减少字符串匹配复杂度  
TypeToID完成了类型与节点的映射  
nodes按照节点编号存储节点，使用vector以便动态加点，且支持随机访问  
IsDeleled存储了节点是否被删除，由于通常删除操作会出现较少，所以直接使用标记数组可以保证复杂度  
若删除过多导致无用数据太多，可以直接将当前图存储并重新初始化，保证均摊复杂度  
graph用连接表的方式存储边的情况，考虑到要维护动态图信息，故使用底层为红黑树的set代替链表，保证信息维护复杂度为$O(logn)$,同时其能保证遍历复杂度是$O(n)$

## 复杂度分析

约定n为节点数,m为边数

Graph.cpp中复杂度分析已经在存储结构中说明，故不再重复
DSU同时使用了路径压缩和按秩合并，复杂度为$O(\alpha (n)),其中\alpha为反阿克曼函数$
接下来是对Algorithm中算法的复杂度分析,其中涉及并查集操作的复杂度不在赘述且不参与分析，均为遍历图的复杂度$O((n+m)\times\alpha(n))$

### 1.GetEulerCircle

该函数实现时采用了fleury算法,由于每次都要寻找一条回路,复杂度为$O(m(m+n))$  

### 2.GetShortestPath

该函数实现时采用了Dijkster算法,复杂度为$O(m\log m)$  

### 3.Kruskal

该函数实现时采用了Kruskal算法,复杂度为$O(m\log m)$,瓶颈在对边进行排序上  

### 4.GetLimitedShortestPath

约定N为输入的topo数量
该函数实现时调用了Dijkster算法,实现方式类似Johnson 全源最短路径算法,由于反复调用Dijkster,复杂度为$O(Nm\log m)$

### 5.GetCutNodes

该函数实现时采用了Tarjan算法,复杂度为$O(m+n)$

## 测试数据说明  

第一组测试数据是图的结构是一条链  

第二组测试数据是一幅随机的图  

第三组测试数据是图的结构是一条环  

第四组测试数据是两个不连通的环  

第五组是随机大数据
